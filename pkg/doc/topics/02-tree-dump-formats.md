# Tree Dump Formats in Oak

## Overview

Oak provides multiple formats for dumping syntax trees generated by tree-sitter. These formats allow you to visualize and analyze the structure of parsed code in different ways, each with its own advantages for specific use cases.

This document explains the available formats, how to use them from both the CLI and programmatically, and provides examples of their output.

## Available Formats

Oak supports four different output formats for syntax tree dumps:

1. **Text Format (text)**: An enhanced human-readable text format with indentation to show nesting. Good for quick inspection and debugging.

2. **XML Format (xml)**: A hierarchical format with explicit tags for nodes and fields. Suitable for processing with XML tools and provides maximum detail.

3. **JSON Format (json)**: A structured format that's easy to parse and process programmatically. Ideal for web-based visualization tools.

4. **YAML Format (yaml)**: A clean, minimally punctuated format that balances human readability with machine parseability.

## Command-Line Usage

The tree dump formats can be used with the `parse` command in the Oak CLI:

```bash
# Basic usage (uses legacy format for backward compatibility)
oak parse file.js

# Using a specific format
oak parse --dump-format=text file.js
oak parse --dump-format=xml file.js
oak parse --dump-format=json file.js
oak parse --dump-format=yaml file.js
```

### Format Options

You can further customize the output with these flags:

```bash
# Show byte offsets in addition to line/column positions
oak parse --dump-format=yaml --show-bytes=true file.js

# Control whether to show node content (source text)
oak parse --dump-format=yaml --show-content=false file.js

# Control whether to show node attributes
oak parse --dump-format=yaml --show-attributes=false file.js

# Control whether to skip whitespace-only nodes
oak parse --dump-format=yaml --skip-whitespace=false file.js
```

The default values for these options are:

- `--show-bytes`: false
- `--show-content`: true
- `--show-attributes`: true
- `--skip-whitespace`: true

## Programmatic API

You can use the tree dump formats programmatically in your Go code:

```go
import (
    "os"

    "github.com/go-go-golems/oak/pkg/cmds"
    tree_sitter "github.com/go-go-golems/oak/pkg/tree-sitter"
    sitter "github.com/smacker/go-tree-sitter"
)

func dumpTree(tree *sitter.Tree, source []byte) error {
    // Create an oak command
    oakCmd := &cmds.OakCommand{}

    // Choose a format
    format := tree_sitter.FormatYAML

    // Configure options
    options := tree_sitter.DumpOptions{
        ShowBytes:      true,
        ShowContent:    true,
        ShowAttributes: true,
        SkipWhitespace: true,
    }

    // Dump the tree to stdout
    return oakCmd.DumpTreeToWriter(tree, source, os.Stdout, format, options)
}
```

Alternatively, you can use the lower-level API directly:

```go
import (
    "os"

    tree_sitter "github.com/go-go-golems/oak/pkg/tree-sitter"
    sitter "github.com/smacker/go-tree-sitter"
)

func dumpTree(tree *sitter.Tree, source []byte) error {
    format := tree_sitter.FormatJSON
    options := tree_sitter.DumpOptions{
        ShowBytes:      true,
        ShowContent:    true,
        ShowAttributes: true,
        SkipWhitespace: true,
    }

    return tree_sitter.DumpTree(tree, source, os.Stdout, format, options)
}
```

## Format Details

### Position Format

All formats use a consistent position representation to indicate where nodes appear in the source code:

- Line/column positions use the format `startLine,startCol-endLine,endCol` (e.g., `1,5-1,10`)
- All line and column numbers are 1-based (starting at 1, not 0) for better alignment with editor conventions
- Byte offsets (when shown) use the format `startByte-endByte` (e.g., `5-10`)

### Text Format

The enhanced text format uses indentation to show the tree structure and includes various node attributes:

```
source_file [1,1-3,2] [named] "func a(b, c, d int) {}"
  function_declaration [1,1-3,2] [named] "func a(b, c, d int) {}"
    func [1,1-1,5] "func"
    name: identifier [1,6-1,7] [named] "a"
    parameters: parameter_list [1,7-1,19] [named] "(b, c, d int)"
      ( [1,7-1,8] "("
      parameter_declaration [1,8-1,18] [named] "b, c, d int"
        name: identifier [1,8-1,9] [named] "b"
        , [1,9-1,10] ","
        name: identifier [1,11-1,12] [named] "c"
        , [1,12-1,13] ","
        name: identifier [1,14-1,15] [named] "d"
        type: type_identifier [1,16-1,19] [named] "int"
      ) [1,18-1,19] ")"
    body: block [1,20-3,2] [named] " {}"
      { [1,20-1,21] "{"
      } [3,1-3,2] "}"
```

### XML Format

The XML format represents the tree as nested XML elements with attributes for node properties:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<tree>
  <node type="source_file" pos="1,1-3,2" named="true" missing="false" extra="false" has_error="false" content="func a(b, c, d int) {}">
    <node type="function_declaration" pos="1,1-3,2" named="true" missing="false" extra="false" has_error="false" content="func a(b, c, d int) {}">
      <node type="func" pos="1,1-1,5" named="false" missing="false" extra="false" has_error="false" content="func"></node>
      <field name="name">
        <node type="identifier" pos="1,6-1,7" named="true" missing="false" extra="false" has_error="false" content="a"></node>
      </field>
      <!-- ... more nodes ... -->
    </node>
  </node>
</tree>
```

### JSON Format

The JSON format represents the tree as a nested JSON structure:

```json
{
  "type": "source_file",
  "pos": "1,1-3,2",
  "is_named": true,
  "content": "func a(b, c, d int) {}",
  "children": [
    {
      "type": "function_declaration",
      "pos": "1,1-3,2",
      "is_named": true,
      "content": "func a(b, c, d int) {}",
      "children": [
        {
          "type": "func",
          "pos": "1,1-1,5",
          "content": "func"
        }
      ],
      "fields": {
        "name": [
          {
            "type": "identifier",
            "pos": "1,6-1,7",
            "is_named": true,
            "content": "a"
          }
        ]
        <!-- ... more fields ... -->
      }
    }
  ]
}
```

### YAML Format

The YAML format represents the tree in a clean, hierarchical structure:

```yaml
type: source_file
pos: 1,1-3,2
named: true
content: "func a(b, c, d int) {}"
children:
  - type: function_declaration
    pos: 1,1-3,2
    named: true
    content: "func a(b, c, d int) {}"
    fields:
      name:
        - type: identifier
          pos: 1,6-1,7
          named: true
          content: a
      # ... more fields ...
    children:
      - type: func
        pos: 1,1-1,5
        content: func
      # ... more children ...
```

## Implementation Details

The tree dump formats are implemented in the `pkg/tree-sitter/dump` package. Each format has its own implementation:

- `TextDumper`: Implements the enhanced text format
- `XMLDumper`: Implements the XML format
- `JSONDumper`: Implements the JSON format
- `YAMLDumper`: Implements the YAML format

All dumpers implement a common interface `Dumper` that defines a `Dump` method:

```go
type Dumper interface {
    Dump(tree *sitter.Tree, source []byte, w io.Writer, options Options) error
}
```

The `pkg/tree-sitter` package provides high-level wrappers around these implementations:

```go
func DumpTree(tree *sitter.Tree, source []byte, w io.Writer, format DumpFormat, options DumpOptions) error
```

And the `pkg/cmds` package integrates these into the Oak command structure:

```go
func (oc *OakCommand) DumpTreeToWriter(tree *sitter.Tree, source []byte, w io.Writer, format tree_sitter.DumpFormat, options tree_sitter.DumpOptions) error
```

## Use Cases

### When to Use Each Format

- **Text Format**: Use for quick debugging and visual inspection when working interactively
- **XML Format**: Use when you need maximum detail or need to process the tree with XML tools
- **JSON Format**: Use for web-based visualization or processing with JavaScript
- **YAML Format**: Use for clean, readable output that's still machine-parseable

### Format Selection Tips

When choosing a format, consider these factors:

1. **Human readability**: Text and YAML formats are the most readable
2. **Processing requirements**: JSON and XML are easier to parse programmatically
3. **Size concerns**: JSON is more compact than XML for large trees
4. **Tool integration**: Choose based on which tools you plan to use with the output

YAML is recommended as a good default choice that balances readability and structure.

## Conclusion

Oak's multiple tree dump formats provide flexibility for various use cases, from debugging to integration with other tools. The consistent position format and configurable options ensure that you can get exactly the information you need in the most appropriate format.
